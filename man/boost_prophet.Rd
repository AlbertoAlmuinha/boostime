% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/parsnip-prophet_boost.R
\name{boost_prophet}
\alias{boost_prophet}
\title{General Interface for Boosted PROPHET Time Series Models}
\usage{
boost_prophet(
  mode = "regression",
  growth = NULL,
  changepoint_num = NULL,
  changepoint_range = NULL,
  seasonality_yearly = NULL,
  seasonality_weekly = NULL,
  seasonality_daily = NULL,
  season = NULL,
  prior_scale_changepoints = NULL,
  prior_scale_seasonality = NULL,
  prior_scale_holidays = NULL,
  logistic_cap = NULL,
  logistic_floor = NULL,
  tree_depth = NULL,
  learn_rate = NULL,
  mtry = NULL,
  trees = NULL,
  min_n = NULL,
  sample_size = NULL,
  loss_reduction = NULL
)
}
\arguments{
\item{mode}{A single character string for the type of model.
The only possible value for this model is "regression".}

\item{growth}{String 'linear' or 'logistic' to specify a linear or logistic trend.}

\item{changepoint_num}{Number of potential changepoints to include for modeling trend.}

\item{changepoint_range}{Adjusts the flexibility of the trend component by limiting to a percentage of data
before the end of the time series. 0.80 means that a changepoint cannot exist after the first 80\% of the data.}

\item{seasonality_yearly}{One of "auto", TRUE or FALSE. Toggles on/off a seasonal component that
models year-over-year seasonality.}

\item{seasonality_weekly}{One of "auto", TRUE or FALSE. Toggles on/off a seasonal component that
models week-over-week seasonality.}

\item{seasonality_daily}{One of "auto", TRUE or FALSE. Toggles on/off a seasonal componet that
models day-over-day seasonality.}

\item{season}{'additive' (default) or 'multiplicative'.}

\item{prior_scale_changepoints}{Parameter modulating the flexibility of the
automatic changepoint selection. Large values will allow many changepoints,
small values will allow few changepoints.}

\item{prior_scale_seasonality}{Parameter modulating the strength of the
seasonality model. Larger values allow the model to fit larger seasonal
fluctuations, smaller values dampen the seasonality.}

\item{prior_scale_holidays}{Parameter modulating the strength of the holiday components model,
unless overridden in the holidays input.}

\item{logistic_cap}{When growth is logistic, the upper-bound for "saturation".}

\item{logistic_floor}{When growth is logistic, the lower-bound for "saturation".}

\item{tree_depth}{The maximum depth of the tree (i.e. number of splits).}

\item{learn_rate}{The rate at which the boosting algorithm adapts from iteration-to-iteration.}

\item{mtry}{The number of predictors that will be randomly sampled at each split when creating the tree models.}

\item{trees}{The number of trees contained in the ensemble.}

\item{min_n}{The minimum number of data points in a node that is required for the node to be split further.}

\item{sample_size}{The amount of data exposed to the fitting routine.}

\item{loss_reduction}{The reduction in the loss function required to split further.}
}
\description{
\code{boost_prophet()} is a way to generate a \emph{specification} of a Boosted PROPHET model
before fitting and allows the model to be created using
different packages. Currently the only package is \code{prophet}.
}
\details{
The data given to the function are not saved and are only used
to determine the \emph{mode} of the model. For \code{boost_prophet()}, the
mode will always be "regression".

The model can be created using the \code{fit()} function using the
following \emph{engines}:
\itemize{
\item "prophet_catboost" (default) - Connects to \code{\link[prophet:prophet]{prophet::prophet()}} and \code{\link[catboost:catboost.train]{catboost::catboost.train()}}
\item "prophet_lightgbm" - Connects to \code{\link[prophet:prophet]{prophet::prophet()}} and \code{\link[lightgbm:lgb.train]{lightgbm::lgb.train()}}
}

\strong{Main Arguments}

The main arguments (tuning parameters) for the \strong{PROPHET} model are:
\itemize{
\item \code{growth}: String 'linear' or 'logistic' to specify a linear or logistic trend.
\item \code{changepoint_num}: Number of potential changepoints to include for modeling trend.
\item \code{changepoint_range}: Range changepoints that adjusts how close to the end
the last changepoint can be located.
\item \code{season}: 'additive' (default) or 'multiplicative'.
\item \code{prior_scale_changepoints}: Parameter modulating the flexibility of the
automatic changepoint selection. Large values will allow many changepoints,
small values will allow few changepoints.
\item \code{prior_scale_seasonality}: Parameter modulating the strength of the
seasonality model. Larger values allow the model to fit larger seasonal
fluctuations, smaller values dampen the seasonality.
\item \code{prior_scale_holidays}: Parameter modulating the strength of the holiday components model,
unless overridden in the holidays input.
}

The main arguments (tuning parameters) for the model \strong{Catboost/LightGBM model} are:
\itemize{
\item \code{tree_depth}: The maximum depth of the tree (i.e. number of splits).
\item \code{learn_rate}: The rate at which the boosting algorithm adapts from iteration-to-iteration.
\item \code{mtry}: The number of predictors that will be randomly sampled at each split when creating the tree models.
\item \code{trees}: The number of trees contained in the ensemble.
\item \code{min_n}: The minimum number of data points in a node that is required for the node to be split further.
\item \code{sample_size}: The amount of data exposed to the fitting routine.
\item \code{loss_reduction}: The reduction in the loss function required to split further.
}

These arguments are converted to their specific names at the
time that the model is fit.

Other options and argument can be
set using \code{set_engine()} (See Engine Details below).

If parameters need to be modified, \code{update()} can be used
in lieu of recreating the object from scratch.
}
\section{Engine Details}{


The standardized parameter names in \code{boostime} can be mapped to their original
names in each engine:

Model 1: PROPHET:\tabular{ll}{
   boostime \tab prophet \cr
   growth \tab growth ('linear') \cr
   changepoint_num \tab n.changepoints (25) \cr
   changepoint_range \tab changepoints.range (0.8) \cr
   seasonality_yearly \tab yearly.seasonality ('auto') \cr
   seasonality_weekly \tab weekly.seasonality ('auto') \cr
   seasonality_daily \tab daily.seasonality ('auto') \cr
   season \tab seasonality.mode ('additive') \cr
   prior_scale_changepoints \tab changepoint.prior.scale (0.05) \cr
   prior_scale_seasonality \tab seasonality.prior.scale (10) \cr
   prior_scale_holidays \tab holidays.prior.scale (10) \cr
   logistic_cap \tab df$cap (NULL) \cr
   logistic_floor \tab df$floor (NULL) \cr
}


Model 2: Catboost / LightGBM:\tabular{lll}{
   boostime \tab catboost::catboost.train \tab lightgbm::lgb.train \cr
   tree_depth \tab depth \tab max_depth \cr
   learn_rate \tab learning_rate \tab learning_rate \cr
   mtry \tab rsm \tab feature_fraction \cr
   trees \tab iterations \tab num_iterations \cr
   min_n \tab min_data_in_leaf \tab min_data_in_leaf \cr
   loss_reduction \tab None \tab min_gain_to_split \cr
   sample_size \tab subsample \tab bagging_fraction \cr
}


Other options can be set using \code{set_engine()}.

\strong{prophet_catboost}

Model 1: PROPHET (\code{prophet::prophet}):\preformatted{## function (df = NULL, growth = "linear", changepoints = NULL, n.changepoints = 25, 
##     changepoint.range = 0.8, yearly.seasonality = "auto", weekly.seasonality = "auto", 
##     daily.seasonality = "auto", holidays = NULL, seasonality.mode = "additive", 
##     seasonality.prior.scale = 10, holidays.prior.scale = 10, changepoint.prior.scale = 0.05, 
##     mcmc.samples = 0, interval.width = 0.8, uncertainty.samples = 1000, 
##     fit = TRUE, ...)
}

Parameter Notes:
\itemize{
\item \code{df}: This is supplied via the parsnip / boostime \code{fit()} interface
(so don't provide this manually). See Fit Details (below).
\item \code{holidays}: A data.frame of holidays can be supplied via \code{set_engine()}
\item \code{uncertainty.samples}: The default is set to 0 because the prophet
uncertainty intervals are not used as part of the Modeltime Workflow.
You can override this setting if you plan to use prophet's uncertainty tools.
}

Logistic Growth and Saturation Levels:
\itemize{
\item For \code{growth = "logistic"}, simply add numeric values for \code{logistic_cap} and / or
\code{logistic_floor}. There is \emph{no need} to add additional columns
for "cap" and "floor" to your data frame.
}

Limitations:
\itemize{
\item \code{prophet::add_seasonality()} is not currently implemented. It's used to
specify non-standard seasonalities using fourier series. An alternative is to use
\code{step_fourier()} and supply custom seasonalities as Extra Regressors.
}

Model 2: Catboost (\code{catboost::catboost.train}):\preformatted{## function (learn_pool, test_pool = NULL, params = list())
}

Parameter Notes:
\itemize{
\item Catboost uses a \code{params = list()} to capture.
Parsnip / Timeboost automatically sends any args provided as \code{...} inside of \code{set_engine()} to
the \code{params = list(...)}.
}

\strong{prophet_lightgbm}

Model 1: PROPHET (\code{prophet::prophet}):\preformatted{## function (df = NULL, growth = "linear", changepoints = NULL, n.changepoints = 25, 
##     changepoint.range = 0.8, yearly.seasonality = "auto", weekly.seasonality = "auto", 
##     daily.seasonality = "auto", holidays = NULL, seasonality.mode = "additive", 
##     seasonality.prior.scale = 10, holidays.prior.scale = 10, changepoint.prior.scale = 0.05, 
##     mcmc.samples = 0, interval.width = 0.8, uncertainty.samples = 1000, 
##     fit = TRUE, ...)
}

Parameter Notes:
\itemize{
\item \code{df}: This is supplied via the parsnip / boostime \code{fit()} interface
(so don't provide this manually). See Fit Details (below).
\item \code{holidays}: A data.frame of holidays can be supplied via \code{set_engine()}
\item \code{uncertainty.samples}: The default is set to 0 because the prophet
uncertainty intervals are not used as part of the Modeltime Workflow.
You can override this setting if you plan to use prophet's uncertainty tools.
}

Logistic Growth and Saturation Levels:
\itemize{
\item For \code{growth = "logistic"}, simply add numeric values for \code{logistic_cap} and / or
\code{logistic_floor}. There is \emph{no need} to add additional columns
for "cap" and "floor" to your data frame.
}

Limitations:
\itemize{
\item \code{prophet::add_seasonality()} is not currently implemented. It's used to
specify non-standard seasonalities using fourier series. An alternative is to use
\code{step_fourier()} and supply custom seasonalities as Extra Regressors.
}

Model 2: Lightgbm (\code{catboost::catboost.train}):\preformatted{## function (params = list(), data, nrounds = 10L, valids = list(), obj = NULL, 
##     eval = NULL, verbose = 1L, record = TRUE, eval_freq = 1L, init_model = NULL, 
##     colnames = NULL, categorical_feature = NULL, early_stopping_rounds = NULL, 
##     callbacks = list(), reset_data = FALSE, ...)
}

Parameter Notes:
\itemize{
\item Lightgbm uses a \code{params = list()} to capture.
Parsnip / Timeboost automatically sends any args provided as \code{...} inside of \code{set_engine()} to
the \code{params = list(...)}.
}
}

\section{Fit Details}{


\strong{Date and Date-Time Variable}

It's a requirement to have a date or date-time variable as a predictor.
The \code{fit()} interface accepts date and date-time features and handles them internally.
\itemize{
\item \code{fit(y ~ date)}
}

\strong{Univariate (No Extra Regressors):}

For univariate analysis, you must include a date or date-time feature. Simply use:
\itemize{
\item Formula Interface (recommended): \code{fit(y ~ date)} will ignore xreg's.
}

\strong{Multivariate (Extra Regressors)}

Extra Regressors parameter is populated using the \code{fit()} or \code{fit_xy()} function:
\itemize{
\item Only \code{factor}, \verb{ordered factor}, and \code{numeric} data will be used as xregs.
\item Date and Date-time variables are not used as xregs
\item \code{character} data should be converted to factor.
}

\emph{Xreg Example:} Suppose you have 3 features:
\enumerate{
\item \code{y} (target)
\item \code{date} (time stamp),
\item \code{month.lbl} (labeled month as a ordered factor).
}

The \code{month.lbl} is an exogenous regressor that can be passed to the \code{arima_reg()} using
\code{fit()}:
\itemize{
\item \code{fit(y ~ date + month.lbl)} will pass \code{month.lbl} on as an exogenous regressor.
}

Note that date or date-time class values are excluded from \code{xreg}.
}

\examples{
library(dplyr)
library(lubridate)
library(parsnip)
library(rsample)
library(timetk)
library(boostime)

# Data
m750 <- m4_monthly \%>\% filter(id == "M750")
m750

# Split Data 80/20
splits <- initial_time_split(m750, prop = 0.8)

# ---- PROPHET ----

# Model Spec
model_spec <- boost_prophet(
    learn_rate = 0.1
) \%>\%
    set_engine("prophet_catboost")

# Fit Spec
model_fit <- model_spec \%>\%
    fit(log(value) ~ date + as.numeric(date) + month(date, label = TRUE),
        data = training(splits))
model_fit

}
\seealso{
\code{\link[=fit.model_spec]{fit.model_spec()}}, \code{\link[=set_engine]{set_engine()}}
}
